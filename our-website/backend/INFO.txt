REACT HOOKS:
React hooks are functions that enable functional components to have state and lifecycle features that were previously only available in class components. Some common React hooks:

1. useState:
- Purpose: Manages state in functional components. (Keeps track of data within a component).
- Syntax:
    const [state, setState] = useState(initialState);
- Reason: Allows functional components to have local state, making it possible to manage and update data within the component.


 2. useEffect:
- Purpose: Performs side effects in functional components (data fetching, subscriptions, manually changing the DOM). (takes care of things that need to happen when your component is born).
- Syntax:
    useEffect(() => {
        // Side effect code here
        return () => {
        // Cleanup code (optional)
        };
    }, [dependencies]);

- Reason: Enables handling of side effects and lifecycle methods in functional components.

    UseEffect in simple (regarding OrderScreen):
    When visit the order page, the component starts in a loading state (loading: true).
    The useEffect runs and triggers the fetchOrder function, which tries to get order details from the server.
    While fetching, it sets the state to indicate loading (loading: true).
    If successful, it updates the state with the fetched order data (loading: false, order: fetchedData).
    If there's an error during fetching, it updates the state to show the error (loading: false, error: errorMessage).
    The reducer function helps manage these state changes.




 3. useContext:
- Purpose: Accesses the value of a React context. (Shares information between components without passing it through props).
- Syntax:
    const contextValue = useContext(MyContext);
- Reason: Allows functional components to consume values provided by a context without the need for a consumer component.



 4. useReducer:
- Purpose: 
In React, components often need to manage and update their internal state. This is where hooks like useState come in handy.
When your component's state logic becomes more complex, involving multiple values or intricate transitions, useReducer is a helpful tool.
useReducer manages more complex state logic.
often in combination with `useContext`, in a structured way.


- Syntax:
    const [state, dispatch] = useReducer(reducer, initialState);
- Reason: Provides a way to handle state updates in a more structured and scalable manner compared to `useState`.



# Reducer:
manages loading and error states during data fetching and updating. It is responsible for updating the state based on different actions.
useReducer uses a function called a "reducer" to handle state updates. The reducer takes the current state and an action as parameters and returns the new state.
Actions are objects that describe what kind of state change you want to make. The reducer interprets these actions and updates the state accordingly.
The reducer function is like a manager. When different actions occur (like requesting, successfully fetching, failing to fetch, or paying), the reducer decides how the state should change.


- Syntax:
function reducer(state, action) {
  switch (action.type) {
    case 'FETCH_REQUEST':
      return { ...state, loading: true, error: '' };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, order: action.payload, error: '' };
    case 'FETCH_FAIL':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}





Simple counter example for useReducer illustration:

import React, { useReducer } from 'react';

// Reducer function
const reducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

// Component using useReducer
const Counter = () => {
  // useReducer returns current state and dispatch function
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      {/* Dispatching actions to update the state */}
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
    </div>
  );
};


In this example:
reducer defines how the state changes in response to different actions.
useReducer(reducer, { count: 0 }) initializes the state with an initial count of 0.
dispatch({ type: 'INCREMENT' }) and dispatch({ type: 'DECREMENT' }) - trigger state updates.

In simple words, useReducer is a way to manage state in a React component when your state logic becomes more complex,
using a predictable pattern of actions and a reducer function to update the state.
(more info in OrderScreen).













5. useNavigate:
Uses useNavigate to get the navigation function.




Summary:
React hooks provide a way to add state and lifecycle features to functional components, making them more powerful and concise,
help functional components do more powerful things, like remembering data, managing effects, sharing information, and handling complex state changes.
Understanding when and how to use these hooks helps in building efficient and maintainable React applications.







HOOKS + EXAMPLES FROM THE CODE:

1. useState:

const [{ loading, summary, error }, dispatch] = useReducer(reducer, {
  loading: true,
  error: '',
});

Explanation:
- "useState" is used to manage the state within your component.
In this example, i"m using "useReducer", which is a hook that includes a state and a dispatch function for updating that state.
- "loading", "summary", and "error" are pieces of state.
- "dispatch" is a function you can call to update the state by dispatching actions.



2. useEffect:
Accpets a function and an array of dependencies.
the dependency array `[userInfo]` in the `useEffect` ensures that the effect runs when there is a change in the `userInfo` variable, allowing you to react to changes in that specific piece of state.

useEffect(() => {
  const fetchData = async () => {
    try {
      const { data } = await axios.get('/api/orders/summary', {
        headers: { Authorization: `Bearer ${userInfo.token}` },
      });
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
    } catch (err) {
      dispatch({
        type: 'FETCH_FAIL',
        payload: getError(err),
      });
    }
  };

  fetchData();
}, [userInfo]);

Explanation:
- useEffect is used for side effects in your component (data fetching, subscriptions).
- In this example, it's fetching data when the component mounts or when userInfo changes.
- The function inside useEffect is the side effect code.
- `userInfo` is specified as a dependency in the dependency array. The [userInfo] in the dependency array ensures that the effect runs when userInfo changes.
- the dependency array is used to specify the dependencies that the effect depends on. When any of the dependencies in the array change, the effect will be re-executed.
- If `userInfo` is initially `null` or some default value, the effect will run when `userInfo` is updated with actual user information.
- It ensures that the data-fetching logic inside the `useEffect` is triggered when there's a change in the `userInfo` variable.
- This is particularly useful for scenarios where you want to fetch or perform actions based on the latest user information.




3. useContext:

const { state } = useContext (Store);
const { userInfo } = state;

Explanation:
- useContext is used to access the value of a React context.
- In this example, it's accessing the state from a context named Store.
- state is an object that likely contains global state information.





4. useReducer:

const [{ loading, summary, error }, dispatch] = useReducer(reducer, {
  loading: true,
  error: '',
});

Explanation:
- useReducer is used for managing more complex state logic, often in combination with useContext.
- The reducer function is provided, which handles state changes based on dispatched actions.
- { loading, summary, error } are pieces of state managed by useReducer.
- dispatch is a function used to dispatch actions, triggering state changes based on the logic defined in the reducer.


















Reducer, useReducer and useEffect -
Separation of Concerns:
The code separates concerns by having a clear distinction between state management (reducer), state logic (useReducer), and side effects (useEffect).
This separation helps maintain a clean and organized codebase.


* reducer Function:
Purpose:
The reducer function is responsible for updating the state based on different actions.
It takes the current state and an action as parameters.
The action's type determines how the state should be updated.

Reason:
This function provides a clear and organized way to handle state updates in response to different actions.
It separates the logic for updating the state from the component, making it easier to manage.


* useReducer Hook:
Purpose:
useReducer is a React hook used to manage complex state logic in a more organized way, especially when the state transitions depend on the previous state and involve multiple actions.
It returns an array containing the current state and a dispatch function.

Reason:
useReducer simplifies state management by centralizing state transitions in a reducer function.
It provides a structured approach for handling state updates in response to actions.
The logger function is used to log state changes in the console, enhancing debugging.


* useEffect Hook:
Purpose:
useEffect is a React hook used for handling side effects in functional components, such as data fetching, subscriptions, or manual DOM manipulations.
It allows you to perform actions after the component has rendered.

Reason:
In this context, useEffect is used to initiate the data fetching process once the component has mounted ([] ensures it runs only once).
It encapsulates asynchronous logic, like making an API call, in a clean and readable way.
The use of dispatch inside useEffect sends actions to the reducer based on the asynchronous operation's different stages.

Summary:
reducer defines how the state should change based on actions.
useReducer is a hook that manages the state using the reducer function.
useEffect handles side effects, such as data fetching, and triggers actions using dispatch.



simplify the concepts: -
* `reducer` Function:
Purpose:
Think of it as a chef's recipe for making your component's state.
It decides how the state should change based on different actions (like fetching data or encountering an error).

Example:
When the chef gets an order to make a sandwich:
If it's a request to start making the sandwich, the chef says, "Alright, let's start!"
If it's a successful delivery of ingredients, the chef says, "Great, here are the ingredients!"
If there's a problem (like no bread), the chef says, "Oops, we have a problem!"


* `useReducer` Hook:
Purpose:
Think of it as a kitchen manager who follows the chef's recipes and keeps track of the kitchen's state.
It manages the state based on the chef's recipes (`reducer` function) and provides a way to update it.

Example:
The kitchen manager keeps an eye on what's happening:
  If the chef starts making a sandwich, the manager notes, "The kitchen is busy."
  If the chef successfully makes the sandwich, the manager notes, "The sandwich is ready!"
  If there's a problem (like missing ingredients), the manager notes, "There's an issue in the kitchen!"


* `useEffect` Hook:
Purpose:
Think of it as a scheduler who tells the chef when to start making the sandwich.
It handles tasks that need to happen after the component is "served" to the user, like fetching data.

Example:
The scheduler waits until the restaurant opens:
 Once the restaurant opens (component mounts), it tells the chef to start making the sandwich.
 The chef follows the recipe (`reducer`), and the kitchen manager (state) is updated based on how things go.


Summary:
The `reducer` is like a recipe for changing the state based on actions.
`useReducer` is like a kitchen manager following the recipe to manage the state.
`useEffect` is like a scheduler deciding when to start the cooking process (fetch data) after the restaurant opens (component mounts).

In simpler terms, `reducer` is the recipe, `useReducer` is the manager following the recipe, and `useEffect` is the scheduler deciding when to start following the recipe.













The architecture used in this code:

1. State Management with `useReducer`:
   - The application's state is managed using the `useReducer` hook. This hook is commonly used for handling complex state logic and state transitions in a more organized way.
   - A `reducer` function is defined to specify how the state should change in response to different actions.

2. Global State:
   - The state managed by `useReducer` is considered global because it holds data that multiple components across the application might need to access or modify.
   - The global state includes properties such as `cart`, `userInfo`, `loading`, `error`, `product`, etc.

3. Side Effects with `useEffect`:
   - The `useEffect` hook is used to handle side effects, such as data fetching. It runs after the component has been rendered.
   - Inside `useEffect`, asynchronous operations are performed, and the state is updated using the `dispatch` function.

4. Separation of Concerns:
   - The code separates concerns by having a clear distinction between state management (`reducer`), state logic (`useReducer`), and side effects (`useEffect`).
   - This separation helps maintain a clean and organized codebase.

5. Component Structure:
   - The application is organized into components, each responsible for a specific part of the user interface.
   - Components are reusable and modular, promoting a component-based architecture.

6. React Router for Navigation:
   - React Router is used for handling navigation within the application. It provides a declarative way to define the application's routes.

7. Conditional Rendering:
   - The code uses conditional rendering to display different UI elements based on the application's state (e.g., loading indicators, error messages, user authentication).

8. Authentication Handling:
   - User authentication is managed through the `userInfo` property in the global state.
   - Certain routes and features are conditionally displayed based on the user's authentication status.

9. Middleware Function (`logger`):
   - A middleware function (`logger`) is used to log state changes in the console. This can be helpful for debugging and understanding how the state evolves.

10. RESTful API Calls with Axios:
   - The application makes API calls to a backend server using the Axios library to fetch data.

In summary, the architecture follows common patterns for building React applications, emphasizing state management, separation of concerns, and modular component-based development. It incorporates best practices for handling global state, side effects, and navigation.


















component MOUNTS:

When we talk about a component "mounting," we are referring to the moment when a React component is being created and inserted into the DOM (Document Object Model) for the first time.
It's the initial rendering phase of the component's lifecycle.

In a React component's lifecycle, the mounting phase includes the following methods:

- `constructor`: The component's constructor is called first, where you typically initialize state and bind event handlers.
- `render`: The `render` method is responsible for generating the component's UI.
- `componentDidMount`: This method is invoked immediately after the component is inserted into the DOM. It's often used to perform tasks like data fetching or setting up subscriptions.



Fetching: "Fetching" refers to retrieving data from a server (backend) to show on the user interface.
